#***************************************************************
#This code ys based on the next example:
#https://www.tensorflow.org/tutorials/images/cnn

#For predict, see the next link:
#https://github.com/christianversloot/machine-learning-articles/blob/main/how-to-predict-new-samples-with-your-keras-model.md

#For use cv2, install in the next way:
#pip install opencv-python
#***************************************************************

import cv2
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import datasets, layers, models


def download_split_cifar_10():
    """
    This function download the CIFAR 10.
    CIFAR 10 contain 60.000 images in colour, separated in 10 clases.
    50.000 images are for training and 10.000 are separated for test.

    Arguments: nothing
    Return: train_images, train_labels, test_images, test_labels 
    """
    
    cifar = "CIFAR 10..."

    f"Downloading, {cifar}."

    #Download CIFAR and separate in training and test data    
    (train_images, train_labels), (test_images, test_labels) = datasets.cifar10.load_data()

    # Normalize pixel values to be between 0 and 1
    train_images, test_images = train_images / 255.0, test_images / 255.0


    return train_images, train_labels, test_images, test_labels 


def convolution_pooling(channels_first_layer, kernel_size, max_pooling_size, channels_other_layer):
    """
    This function procces the convolution and th pooling using maxpooling.

    Args: Channels

    Return:
    
    """

    #Sequential model
    model = models.Sequential()
    
    #Add layers.
    #For Conv2d define the channel_layer, kernel_size, activation function and input shape
    #For Max Pooling define the dimensions
    model.add(layers.Conv2D(channels_first_layer, (kernel_size, kernel_size), activation='relu', input_shape=(32, 32, 3)))
    model.add(layers.MaxPooling2D((max_pooling_size, max_pooling_size)))
    model.add(layers.Conv2D(channels_other_layer, (kernel_size, kernel_size), activation='relu'))
    model.add(layers.MaxPooling2D((max_pooling_size, max_pooling_size)))
    model.add(layers.Conv2D(channels_other_layer, (kernel_size, kernel_size), activation='relu'))

    return model


def mlp(model, channels_last_layer, output_layer):
    """
    This function add a flatten and process the image after the convolution

    Args: model, channels_last_layer, output_layer
    Return: model with the MLP added
    """
    #The output layer is the number of th output to be classified
    model.add(layers.Flatten())
    model.add(layers.Dense(channels_last_layer, activation='relu'))
    model.add(layers.Dense(output_layer))

    return model

def compile(model):
    """
    Compile the model

    Args: model with the CNN and MLP
    Return: model compiled with the optimizer, loss and metrics

    """

    model.compile(optimizer='adam', 
                loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
                metrics=['accuracy'])

    return model


def fit_model(model, train_images, train_labels, test_images, test_labels, epochs):
    """
    Fit the model

    Args: model compiled
    Return: model fitted
    """

    model_fitted = model.fit(train_images, train_labels, epochs=epochs, 
                    validation_data=(test_images, test_labels))

    
    return model_fitted


def evaluate_model(model_compiled, model_fitted, test_images, test_labels):
    """
    This function evaluate the model

    Args: model_fitted
    Plot the accuracy
    """

    plt.plot(model_fitted.history['accuracy'], label='accuracy')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.ylim([0.5, 1])
    plt.legend(loc='lower right')
    plt.grid()
    plt.show()

    test_loss, test_acc = model_compiled.evaluate(test_images,  test_labels, verbose=2)


def predict_image(image, image_dimension, image_channels, compile_model):
    """
    This function take a picture and predict the class. 

    Args: image
    Return: class of the image
    """

    read_image = cv2.imread(image)
    resize_image = cv2.resize(read_image,(image_dimension,image_dimension))
    reshape_image = np.reshape(resize_image,[1,image_dimension,image_dimension,image_channels])

    #Generate predictions for samples.
    #Have in mind that Softmax computes 
    #the probability that the input belongs to a particular class, for each class.
    predictions = compile_model.predict(reshape_image)

    #Take the max value generated by predictions. This is the class predicted.
    classes = np.argmax(predictions, axis = 1)

    class_names = ['airplane', 'automobile', 'bird', 'cat', 'deer',
               'dog', 'frog', 'horse', 'ship', 'truck']
    
    class_image = class_names[int(classes)]
  
    return class_image  